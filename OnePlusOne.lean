import Mathlib

/-
Let's prove that 1 + 1 = 2!
-/

namespace Sandbox

/-
First, we define natural numbers by induction:
-/

inductive Nat where
| zero
| succ (n : Nat)

/-
Think of the successor `succ n` (or `n.succ`) as `n +1` where `+1` is a symbol
by itself. Addition `+` has not been defined yet! Let's do it now:
-/

def add (m n : Nat) : Nat :=
  match n with
  | Nat.zero => m
  | Nat.succ n => (add m n).succ

/-
Let's check that it works as expected:
-/

#eval add Nat.zero Nat.zero
-- Sandbox.Nat.zero

#reduce add Nat.zero Nat.zero
-- Nat.zero

#reduce add Nat.zero Nat.zero.succ
-- Nat.zero.succ

#reduce add Nat.zero.succ Nat.zero
-- Nat.zero.succ

#reduce add Nat.zero.succ Nat.zero.succ
-- Nat.zero.succ.succ

/-
We could also have defined `add` by the terser
-/

def add' (m : Nat) : Nat -> Nat
| Nat.zero => m
| Nat.succ n => (add m n).succ

/-
Lean automatically generate inherit equations for such recursive functions:
-/


/-
Theorem `∀ n, n + 0 = n`
-/
#check add.eq_1
-- Sandbox.add.eq_1 (m : Nat) : add m Nat.zero = m

/-
Theorem `∀ m n, m + (n +1) = (m + n) +1`
-/
#check add.eq_2
-- Sandbox.add.eq_2 (m n_2 : Nat) : add m n_2.succ = (add m n_2).succ

/-
If you don't know that, you can derive these equations manually quite easily:
both terms of the equation hold "by definition", so we only need to invoke
reflexivity of equality (the fact that for all `x`, we have `x = x`).
-/

theorem add_zero (n : Nat) : add n Nat.zero = n :=
  Eq.refl n -- or by rfl

theorem add_succ (m n : Nat) : add m n.succ = (add m n).succ :=
  Eq.refl (add m n.succ) -- or Eq.refl _, or by rfl

/-
With tactics, there are many ways to prove our main result. A very elementary,
step by step rewrite approach yields:
-/

theorem v0.one_plus_one_eq_two : add (Nat.zero.succ) (Nat.zero.succ) = Nat.zero.succ.succ := by
  rewrite [add]
  rewrite [add]
  rfl

/-
A slightly more compact approach with `rw` (that includes reflexivity check):
-/

theorem v1.one_plus_one_eq_two : add (Nat.zero.succ) (Nat.zero.succ) = Nat.zero.succ.succ := by
  repeat rw [add]

/-
But actually here the equality holds by definition:
-/

theorem v2.one_plus_one_eq_two : add (Nat.zero.succ) (Nat.zero.succ) = Nat.zero.succ.succ := by
  rfl

/-
We can actually ask Lean for the expression of the proof that is generated by
the tactics:
-/

#print v2.one_plus_one_eq_two
-- theorem Sandbox.one_plus_one_eq_two : add Nat.zero.succ Nat.zero.succ = Nat.zero.succ.succ :=
-- Eq.mpr (id (congrArg (fun _a => _a = Nat.zero.succ.succ) (add.eq_2 Nat.zero.succ Nat.zero)))
--   (Eq.mpr (id (congrArg (fun _a => _a.succ = Nat.zero.succ.succ) (add.eq_1 Nat.zero.succ)))
--     (Eq.refl Nat.zero.succ.succ))

#check Eq.mpr
-- Eq.mpr.{u} {α β : Sort u} (h : α = β) (b : β) : α

#check id
-- id.{u} {α : Sort u} (a : α) : α

#check congrArg
-- congrArg.{u, v} {α : Sort u} {β : Sort v} {a₁ a₂ : α}
-- (f : α → β) (h : a₁ = a₂) : f a₁ = f a₂

/-
Let's copy the expression provided by #print to define directly the proof,
without tactics.
-/

theorem v3.one_plus_one_eq_two :
add Nat.zero.succ Nat.zero.succ = Nat.zero.succ.succ :=
  Eq.mpr
    (id
      (congrArg
        (fun _a => _a = Nat.zero.succ.succ)
        (add.eq_2 Nat.zero.succ Nat.zero)
      )
    )
    (Eq.mpr
      (id
        (congrArg
          (fun _a => _a.succ = Nat.zero.succ.succ)
          (add.eq_1 Nat.zero.succ))
        )
      (Eq.refl Nat.zero.succ.succ)
    )

/-
This version can be decomposed, simplified and analyzed.
-/

theorem v4.one_plus_one_eq_two : add Nat.zero.succ Nat.zero.succ = Nat.zero.succ.succ :=
  have h1 := congrArg
    (·  = Nat.zero.succ.succ)
    (add.eq_2 Nat.zero.succ Nat.zero)
  have h2 := congrArg
    (·.succ = Nat.zero.succ.succ)
    (add.eq_1 Nat.zero.succ)
  have h3 := Eq.mpr h2 (Eq.refl Nat.zero.succ.succ)
  Eq.mpr h1 h3

/-
Of course we can also think for a minute and come up with a proof directly,
without tactics.
-/

theorem v5.one_plus_one_eq_two : add Nat.zero.succ Nat.zero.succ = Nat.zero.succ.succ :=
  -- `∀ n, n + 1 = (n + 0) +1`
  have plus_one_eq_succ_n_add_zero (n : Nat) :
  (add n Nat.zero.succ) = (add n Nat.zero).succ :=
    add.eq_2 n Nat.zero

  -- `∀ n, (n + 0) +1 = n +1`
  have succ_n_add_zero_eq_succ_n (n : Nat) : (add n Nat.zero).succ = n.succ :=
    congrArg (·.succ) (add.eq_1 n)

  -- `∀ n, n + 1 = n +1`
  have add_one_eq_succ (n : Nat) : (add n Nat.zero.succ) = n.succ :=
    Eq.trans (plus_one_eq_succ_n_add_zero n) (succ_n_add_zero_eq_succ_n n)

  -- `1 + 1 = 1 +1 (= 2)` is actually a special case of this local lemma
  add_one_eq_succ Nat.zero.succ

/-
The version without the intermediate steps
-/

theorem v6.one_plus_one_eq_two : add Nat.zero.succ Nat.zero.succ = Nat.zero.succ.succ :=
  Eq.trans
    (add.eq_2 Nat.zero.succ Nat.zero)
    (congrArg (·.succ) (add.eq_1 Nat.zero.succ))

/-
Syntactic sugar
-/

def Nat.add : Nat -> Nat -> Nat := Sandbox.add

instance : Add Nat where
  add := Nat.add

def Nat.toNat : Nat -> _root_.Nat
| Nat.zero => _root_.Nat.zero
| Nat.succ n => n.toNat.succ

instance : ToString Nat where
  toString := (· |>.toNat |> toString)

def Nat.ofNat : _root_.Nat → Nat
  | 0 => Nat.zero
  | n + 1 => Nat.succ (Nat.ofNat n)

instance {n} : OfNat Nat n where
  ofNat := Nat.ofNat n

#eval add Nat.zero Nat.zero
-- 0

#eval add Nat.zero Nat.zero.succ
-- 1

#eval add Nat.zero.succ Nat.zero
-- 1

#eval add Nat.zero.succ Nat.zero.succ
-- 2

theorem v7.one_plus_one_eq_two : (1 : Nat) + (1 : Nat) = (2 : Nat) := by
  -- rw [HAdd.hAdd]
  -- rw [instHAdd]
  -- simp
  -- rw [Add.add]
  -- rw [instAddNat]
  -- simp
  -- rw [Nat.add]
  exact v6.one_plus_one_eq_two




/-
Extra stuff
-/

theorem eq_of_succ_eq_succ {m n : Nat} : m.succ = n.succ -> m = n := by
  intro m_succ_eq_n_succ
  cases m_succ_eq_n_succ
  rfl

theorem succ_eq_succ_of_eq {m n : Nat} : m = n -> m.succ = n.succ := by
  intro m_eq_n
  exact congrArg Nat.succ m_eq_n

end Sandbox
