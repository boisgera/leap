import Mathlib

set_option pp.showLetValues true


-- TODO: explore the fact that in ℝ, Cauchy sequences converge.

-- TODO: show that for real-valued sequences, the standard `CauchySeq` and
--       our simple `IsCauchy` are equivalent. Do the same for limits and
--       deduce a simple, concrete version of "ℝ is complete".

/-!
⚠️ Many new definitions to consider!
-/

#print CauchySeq
-- def CauchySeq.{u, v} : {α : Type u} → {β : Type v} →
-- [uniformSpace : UniformSpace α] → [Preorder β] → (β → α) → Prop :=
-- fun {α} {β} [UniformSpace α] [Preorder β] u => Cauchy (Filter.map u Filter.atTop)

#check Preorder -- ≤ which is reflexive and transitive; for us: ℕ
-- Preorder.{u_2} (α : Type u_2) : Type u_2

#check UniformSpace -- Here for us: ℝ
-- Think of it as something a bit weaker than "metric space";
-- the mere "topological space" is not enough to define Cauchy filter.
-- This is actually a topological space with a "uniform structure" with four
-- additional axioms.
-- UniformSpace.{u} (α : Type u) : Type u

/-!
What `CauchySeq a` captures when `a : ℕ → ℝ` is that "some filter based on a
is Cauchy". Need to investigate:
  - what is a filter,
  - what is this filter,
  - what is a Cauchy filter.
-/

#print Filter
-- structure Filter.{u_1} (α : Type u_1) : Type u_1
-- number of parameters: 1
-- fields:
--   Filter.sets : Set (Set α)
--   Filter.univ_sets : Set.univ ∈ self.sets
--   Filter.sets_of_superset : ∀ {x y : Set α}, x ∈ self.sets → x ⊆ y → y ∈ self.sets
--   Filter.inter_sets : ∀ {x y : Set α}, x ∈ self.sets → y ∈ self.sets → x ∩ y ∈ self.sets
-- constructor:
--   Filter.mk.{u_1} {α : Type u_1} (sets : Set (Set α)) (univ_sets : Set.univ ∈ sets)
--     (sets_of_superset : ∀ {x y : Set α}, x ∈ sets → x ⊆ y → y ∈ sets)
--     (inter_sets : ∀ {x y : Set α}, x ∈ sets → y ∈ sets → x ∩ y ∈ sets) : Filter α

#print Filter.atTop -- "neighborhood" of "+∞" I guess?
-- def Filter.atTop.{u_3} : {α : Type u_3} → [Preorder α] → Filter α :=
-- fun {α} [Preorder α] => ⨅ a, Filter.principal (Set.Ici a)

-- Note that filters instantiate ⊓ (inf) via `Filter.instInfSet`

#check Filter.instInfSet
-- Filter.instInfSet.{u_1} {α : Type u_1} : InfSet (Filter α)

#print Set.Ici -- "Interval closed-infinity: Ici" (I guess)
-- def Set.Ici.{u_1} : {α : Type u_1} → [Preorder α] → α → Set α :=
-- fun {α} [Preorder α] a => {x | a ≤ x}

#print Filter.principal
-- def Filter.principal.{u_1} : {α : Type u_1} → Set α → Filter α :=
-- fun {α} s => {
--   sets := {t | s ⊆ t},
--   univ_sets := ⋯,
--   sets_of_superset := ⋯,
--   inter_sets := ⋯
-- }

/-!
OK, at this stage the definition of `CauchySeq` (partially) makes sense:
a sequence is Cauchy if the image of the "neighbourhood of +∞" by the sequence
is a Cauchy filter. But the definition of a Cauchy filter (in a uniform space)
is quite a bitch. Consider:
-/

#print Cauchy
-- def Cauchy.{u} : {α : Type u} → [uniformSpace : UniformSpace α] →
--     Filter α → Prop :=
-- fun {α} [UniformSpace α] f => f.NeBot ∧ f ×ˢ f ≤ uniformity α

-- That reads: a filter on α is Cauchy if:
--   - It does not contain ∅ (equi., it is not all the subsets of α)
--     (i.e. it is a filter according to Bourbaki)
--   - The filter generated by the product is finer than the uniform
--     structure of the space.

-- That's a fucking shitload of things to unpack/specialize.
-- Let's start with Cauchy filter on metric spaces maybe?
-- And see what we can simplify?

#check Metric.mem_uniformity_dist
-- Metric.mem_uniformity_dist.{u} {α : Type u} [PseudoMetricSpace α] {s : Set (α × α)} :
--     s ∈ uniformity α ↔ ∃ ε > 0, ∀ ⦃a b : α⦄, dist a b < ε → (a, b) ∈ s

#check Filter.mem_prod_iff
-- Filter.mem_prod_iff.{u_1, u_2}
--   {α : Type u_1} {β : Type u_2} {s : Set (α × β)} {f : Filter α} {g : Filter β} :
--   s ∈ f ×ˢ g ↔ ∃ t₁ ∈ f, ∃ t₂ ∈ g, t₁ ×ˢ t₂ ⊆ s


-- TODO: Arf, we need to make another pass to prove the converse: what we want
-- is something like Cauchy f ↔ ...

theorem cauchy_for_dummies {α} [m : MetricSpace α] {f : Filter α} :
    Cauchy f ↔
    f.NeBot ∧
    ∀ ε > 0, ∃ s₁ ∈ f, ∃ s₂ ∈ f, s₁ ×ˢ s₂ ⊆ {(x, y) : α × α | dist x y < ε} := by
  simp only [
    Cauchy,
    Filter.le_def,
    Metric.mem_uniformity_dist,
    Filter.mem_prod_iff
  ]
  constructor
  . intro ⟨h, le⟩
    constructor
    . exact h
    . intro ε ε_pos
      let s := {(x, y) : α × α | dist x y < ε}
      have : ∃ ε > 0, ∀ a b : α, dist a b < ε → (a, b) ∈ s := by grind
      apply le
      exact this
  . intro h
    let ⟨f_neBot, h'⟩ := h
    constructor
    . exact f_neBot
    . grind

-- Specialize to sequences
theorem cauchySeq_for_dummies {α} [m : MetricSpace α] (a : ℕ → α) :
    CauchySeq a ↔
    ∀ ε > 0, ∃ n, ∀ i ≥ n, ∀ j ≥ n, dist (a i) (a j) < ε := by
  simp only [CauchySeq]
  have f_aTop {x : Set α} :
      x ∈ Filter.map a Filter.atTop ↔ ∃ m, ∀ n ≥ m, a n ∈ x := by
      simp only [
        Filter.mem_map,
        Filter.mem_atTop_sets,
        ge_iff_le,
        Set.mem_preimage
      ]
  constructor
  . intro c
    have ⟨f_neBot, h⟩ := cauchy_for_dummies.mp c
    simp only [f_aTop] at h
    intro ε ε_pos
    specialize h ε ε_pos
    let ⟨s₁, ⟨m₁, h₁⟩, s₂, ⟨m₂, h₂⟩, h₃⟩ := h
    let n := max m₁ m₂
    use n
    intro i i_ge_n j j_ge_n
    specialize h₁ i (show i ≥ m₁ from by grind)
    specialize h₂ j (show j ≥ m₂ from by grind)
    have : (a i, a j) ∈ s₁ ×ˢ s₂ := by grind
    specialize h₃ this
    simp only [Set.mem_setOf_eq] at h₃
    exact h₃
  . intro h
    apply cauchy_for_dummies.mpr
    constructor
    . admit
    . simp only [f_aTop]
      intro ε ε_pos
      specialize h ε ε_pos
      have ⟨n, hn⟩ := h
      use Set.image a {i : ℕ | i ≥ n}
      constructor
      . use n
        admit
      . use Set.image a {i : ℕ | i ≥ n}
        admit

-- Specialize to real-valued sequences
theorem real_cauchySeq_for_dummies (a : ℕ → ℝ) :
    CauchySeq a ↔
    ∀ ε > 0, ∃ n, ∀ i ≥ n, ∀ j ≥ n, |a i -  a j| < ε := by
  admit
