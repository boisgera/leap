import Mathlib

-- TODO: explore the fact that in ℝ, Cauchy sequences converge.

-- TODO: show that for real-valued sequences, the standard `CauchySeq` and
--       our simple `IsCauchy` are equivalent. Do the same for limits and
--       deduce a simple, concrete version of "ℝ is complete".

/-!
⚠️ Many new definitions to consider!
-/

#print CauchySeq
-- def CauchySeq.{u, v} : {α : Type u} → {β : Type v} →
-- [uniformSpace : UniformSpace α] → [Preorder β] → (β → α) → Prop :=
-- fun {α} {β} [UniformSpace α] [Preorder β] u => Cauchy (Filter.map u Filter.atTop)

#check Preorder -- ≤ which is reflexive and transitive; for us: ℕ
-- Preorder.{u_2} (α : Type u_2) : Type u_2

#check UniformSpace -- Here for us: ℝ
-- Think of it as something a bit weaker than "metric space";
-- the mere "topological space" is not enough to define Cauchy filter.
-- This is actually a topological space with a "uniform structure" with four
-- additional axioms.
-- UniformSpace.{u} (α : Type u) : Type u

/-!
What `CauchySeq a` captures when `a : ℕ → ℝ` is that "some filter based on a
is Cauchy". Need to investigate:
  - what is a filter,
  - what is this filter,
  - what is a Cauchy filter.
-/

#print Filter
-- structure Filter.{u_1} (α : Type u_1) : Type u_1
-- number of parameters: 1
-- fields:
--   Filter.sets : Set (Set α)
--   Filter.univ_sets : Set.univ ∈ self.sets
--   Filter.sets_of_superset : ∀ {x y : Set α}, x ∈ self.sets → x ⊆ y → y ∈ self.sets
--   Filter.inter_sets : ∀ {x y : Set α}, x ∈ self.sets → y ∈ self.sets → x ∩ y ∈ self.sets
-- constructor:
--   Filter.mk.{u_1} {α : Type u_1} (sets : Set (Set α)) (univ_sets : Set.univ ∈ sets)
--     (sets_of_superset : ∀ {x y : Set α}, x ∈ sets → x ⊆ y → y ∈ sets)
--     (inter_sets : ∀ {x y : Set α}, x ∈ sets → y ∈ sets → x ∩ y ∈ sets) : Filter α

#print Filter.atTop -- "neighborhood" of "+∞" I guess?
-- def Filter.atTop.{u_3} : {α : Type u_3} → [Preorder α] → Filter α :=
-- fun {α} [Preorder α] => ⨅ a, Filter.principal (Set.Ici a)

-- Note that filters instantiate ⊓ (inf) via `Filter.instInfSet`

#check Filter.instInfSet
-- Filter.instInfSet.{u_1} {α : Type u_1} : InfSet (Filter α)

#print Set.Ici -- "Interval closed-infinity: Ici" (I guess)
-- def Set.Ici.{u_1} : {α : Type u_1} → [Preorder α] → α → Set α :=
-- fun {α} [Preorder α] a => {x | a ≤ x}

#print Filter.principal
-- def Filter.principal.{u_1} : {α : Type u_1} → Set α → Filter α :=
-- fun {α} s => {
--   sets := {t | s ⊆ t},
--   univ_sets := ⋯,
--   sets_of_superset := ⋯,
--   inter_sets := ⋯
-- }

/-!
OK, at this stage the definition of `CauchySeq` (partially) makes sense:
a sequence is Cauchy if the image of the "neighbourhood of +∞" by the sequence
is a Cauchy filter. But the definition of a Cauchy filter (in a uniform space)
is a bitch. Consider:
-/

#print Cauchy
-- def Cauchy.{u} : {α : Type u} → [uniformSpace : UniformSpace α] →
--     Filter α → Prop :=
-- fun {α} [UniformSpace α] f => f.NeBot ∧ f ×ˢ f ≤ uniformity α

-- That reads: a filter on α is Cauchy if:
--   - It does not contain ∅ (equi., it is not all the subsets of α)
--     (i.e. it is a filter according to Bourbaki)
--   - The filter generated by the product is finer than the uniform
--     structure of the space.

-- That's a fucking shitload of things to unpack/specialize.
-- Let's start with Cauchy filter on metric spaces maybe?
-- And see what we can simplify?

#check Metric.mem_uniformity_dist
-- Metric.mem_uniformity_dist.{u} {α : Type u} [PseudoMetricSpace α] {s : Set (α × α)} :
--     s ∈ uniformity α ↔ ∃ ε > 0, ∀ ⦃a b : α⦄, dist a b < ε → (a, b) ∈ s

example {α : Type u} [m : MetricSpace α] {f : Filter α} (c : Cauchy f) : True
   -- So far, we have:
    -- ∀ (x : Set (α × α)), (∃ ε > 0, ∀ ⦃a b : α⦄, dist a b < ε → (a, b) ∈ x) → x ∈ f ×ˢ f
    -- To go beyond that we probably need to rw/simp/charac ×ˢ
    := by
  rw [Cauchy] at c
  have ⟨h, le⟩ := c
  rw [Filter.le_def] at le
  simp only [Metric.mem_uniformity_dist] at le
  rw [Filter.prod_eq_inf] at le
  simp [Filter.mem_inf_iff] at le -- , Filter.mem_comap, Filter.mem_comap] at le

  admit

  -- Mechanical rewriting without the lemmas is a rabbit hole that goes nowhere aifaict
  -- rw [uniformity] at le -- f ×ˢ f ≤ UniformSpace.uniformity
  -- rw [UniformSpace.uniformity] at le -- f ×ˢ f ≤ PseudoMetricSpace.toUniformSpace.2
  -- rw [PseudoMetricSpace.toUniformSpace] at le -- f ×ˢ f ≤ m.toPseudoMetricSpace.7.2
  -- rw [MetricSpace.toPseudoMetricSpace] at le -- f ×ˢ f ≤ m.1.7.2

  admit
