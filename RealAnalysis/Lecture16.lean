import Mathlib

set_option pp.showLetValues true


-- TODO: explore the fact that in ℝ, Cauchy sequences converge.

-- TODO: show that for real-valued sequences, the standard `CauchySeq` and
--       our simple `IsCauchy` are equivalent. Do the same for limits and
--       deduce a simple, concrete version of "ℝ is complete".

/-!
⚠️ Many new definitions to consider!
-/

#print CauchySeq
-- def CauchySeq.{u, v} : {α : Type u} → {β : Type v} →
-- [uniformSpace : UniformSpace α] → [Preorder β] → (β → α) → Prop :=
-- fun {α} {β} [UniformSpace α] [Preorder β] u => Cauchy (Filter.map u Filter.atTop)

#check Preorder -- ≤ which is reflexive and transitive; for us: ℕ
-- Preorder.{u_2} (α : Type u_2) : Type u_2

#check UniformSpace -- Here for us: ℝ
-- Think of it as something a bit weaker than "metric space";
-- the mere "topological space" is not enough to define Cauchy filter.
-- This is actually a topological space with a "uniform structure" with four
-- additional axioms.
-- UniformSpace.{u} (α : Type u) : Type u

/-!
What `CauchySeq a` captures when `a : ℕ → ℝ` is that "some filter based on a
is Cauchy". Need to investigate:
  - what is a filter,
  - what is this filter,
  - what is a Cauchy filter.
-/

#print Filter
-- structure Filter.{u_1} (α : Type u_1) : Type u_1
-- number of parameters: 1
-- fields:
--   Filter.sets : Set (Set α)
--   Filter.univ_sets : Set.univ ∈ self.sets
--   Filter.sets_of_superset : ∀ {x y : Set α}, x ∈ self.sets → x ⊆ y → y ∈ self.sets
--   Filter.inter_sets : ∀ {x y : Set α}, x ∈ self.sets → y ∈ self.sets → x ∩ y ∈ self.sets
-- constructor:
--   Filter.mk.{u_1} {α : Type u_1} (sets : Set (Set α)) (univ_sets : Set.univ ∈ sets)
--     (sets_of_superset : ∀ {x y : Set α}, x ∈ sets → x ⊆ y → y ∈ sets)
--     (inter_sets : ∀ {x y : Set α}, x ∈ sets → y ∈ sets → x ∩ y ∈ sets) : Filter α

#print Filter.atTop -- "neighborhood" of "+∞" I guess?
-- def Filter.atTop.{u_3} : {α : Type u_3} → [Preorder α] → Filter α :=
-- fun {α} [Preorder α] => ⨅ a, Filter.principal (Set.Ici a)

-- Note that filters instantiate ⊓ (inf) via `Filter.instInfSet`

#check Filter.instInfSet
-- Filter.instInfSet.{u_1} {α : Type u_1} : InfSet (Filter α)

#print Set.Ici -- "Interval closed-infinity: Ici" (I guess)
-- def Set.Ici.{u_1} : {α : Type u_1} → [Preorder α] → α → Set α :=
-- fun {α} [Preorder α] a => {x | a ≤ x}

#print Filter.principal
-- def Filter.principal.{u_1} : {α : Type u_1} → Set α → Filter α :=
-- fun {α} s => {
--   sets := {t | s ⊆ t},
--   univ_sets := ⋯,
--   sets_of_superset := ⋯,
--   inter_sets := ⋯
-- }

/-!
OK, at this stage the definition of `CauchySeq` (partially) makes sense:
a sequence is Cauchy if the image of the "neighbourhood of +∞" by the sequence
is a Cauchy filter. But the definition of a Cauchy filter (in a uniform space)
is quite a bitch. Consider:
-/

#print Cauchy
-- def Cauchy.{u} : {α : Type u} → [uniformSpace : UniformSpace α] →
--     Filter α → Prop :=
-- fun {α} [UniformSpace α] f => f.NeBot ∧ f ×ˢ f ≤ uniformity α

-- That reads: a filter on α is Cauchy if:
--   - It does not contain ∅ (equi., it is not all the subsets of α)
--     (i.e. it is a filter according to Bourbaki)
--   - The filter generated by the product is finer than the uniform
--     structure of the space.

-- That's a fucking shitload of things to unpack/specialize.
-- Let's start with Cauchy filter on metric spaces maybe?
-- And see what we can simplify?

#check Metric.mem_uniformity_dist
-- Metric.mem_uniformity_dist.{u} {α : Type u} [PseudoMetricSpace α] {s : Set (α × α)} :
--     s ∈ uniformity α ↔ ∃ ε > 0, ∀ ⦃a b : α⦄, dist a b < ε → (a, b) ∈ s

#check Filter.mem_prod_iff
-- Filter.mem_prod_iff.{u_1, u_2}
--   {α : Type u_1} {β : Type u_2} {s : Set (α × β)} {f : Filter α} {g : Filter β} :
--   s ∈ f ×ˢ g ↔ ∃ t₁ ∈ f, ∃ t₂ ∈ g, t₁ ×ˢ t₂ ⊆ s

-- Wait we could probably simplify the hypothesis "being a neighbourhood of the
-- diagonal" further, right? Yes, we could pick for such neighbourghoods exactly
-- the set of points (x, y) such that dist x y < ε !!!
theorem t₁ {α} [m : MetricSpace α] {f : Filter α} (c : Cauchy f) :
    ∀ (x : Set (α × α)),
    (∃ ε > 0, ∀ ⦃a b : α⦄, dist a b < ε → (a, b) ∈ x) →
    ∃ t₁ ∈ f, ∃ t₂ ∈ f, t₁ ×ˢ t₂ ⊆ x := by
  rw [Cauchy] at c
  have ⟨h, le⟩ := c
  rw [Filter.le_def] at le
  simp only [Metric.mem_uniformity_dist] at le
  simp only [Filter.mem_prod_iff] at le
  exact le

  -- Mechanical rewriting without the lemmas is a rabbit hole that goes nowhere aifaict
  -- rw [uniformity] at le -- f ×ˢ f ≤ UniformSpace.uniformity
  -- rw [UniformSpace.uniformity] at le -- f ×ˢ f ≤ PseudoMetricSpace.toUniformSpace.2
  -- rw [PseudoMetricSpace.toUniformSpace] at le -- f ×ˢ f ≤ m.toPseudoMetricSpace.7.2
  -- rw [MetricSpace.toPseudoMetricSpace] at le -- f ×ˢ f ≤ m.1.7.2

theorem t₂ {α} [m : MetricSpace α] {f : Filter α} (c : Cauchy f) :
    ∀ ε > 0, ∃ t₁ ∈ f, ∃ t₂ ∈ f, t₁ ×ˢ t₂ ⊆ {(x, y) : α × α | dist x y < ε} := by
  intro ε ε_pos
  let s := {(x, y) : α × α | dist x y < ε}
  have k : ∃ ε > 0, ∀ a b : α, dist a b < ε → (a, b) ∈ s := by
    use ε
    constructor
    . linarith [ε_pos]
    . exact fun _ _ h => h
  apply t₁ c s
  exact k


-- TODO: specialize
theorem t₃ {α} [m : MetricSpace α] (a : ℕ → α) (c : CauchySeq a) :
    ∀ ε > 0, ∃ n : ℕ, ∀ i ≥ n, ∀ j ≥ n, dist (a i) (a j) < ε
:= by
  rw [CauchySeq] at c
  have h : ∀ ε > 0,
      ∃ t₁ ∈ Filter.map a Filter.atTop, -- need to simplify these assump.
      ∃ t₂ ∈ Filter.map a Filter.atTop,
      t₁ ×ˢ t₂ ⊆ {(x, y) | dist x y < ε} := t₂ c
  have lem {x : Set α} :
      x ∈ Filter.map a Filter.atTop ↔
      ∃ m, ∀ n ≥ m, a n ∈ x := by simp
  simp only [lem] at h

  admit
